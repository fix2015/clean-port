(()=>{"use strict";var t={136:(t,s,r)=>{const e=r(96),o=r(785);class i{constructor(t,{method:s="tcp",action:r="check",interactive:e=!1,dryRun:o=!1,verbose:i=!1,graceful:n=!1,filter:a=null,range:c=null,speed:l="safe"}={}){this.ports=t,this.method=s,this.action=r,this.interactive=e,this.dryRun=o,this.verbose=i,this.graceful=n,this.filter=a,this.range=c,this.speed=l,this.platform=process.platform}log(t){this.verbose&&console.log(t)}parsePorts(){if(Array.isArray(this.ports))return this.ports.map(Number).filter(Boolean);if(this.range){const[t,s]=this.range.split("-").map(Number);return Array.from({length:s-t+1},((s,r)=>t+r))}{const t=Number(this.ports);return t?[t]:[]}}async execute(){const t=this.parsePorts();if(0===t.length)throw new Error("Invalid or no port(s) provided.");if(!this.dryRun){if(this.interactive){const t=await this.listActivePorts(),s=await this.promptUserToSelectPorts(t);return this.handlePorts(s)}return this.handlePorts(t)}this.success(`Dry run: Ports to operate on - ${t.join(", ")}`)}async listActivePorts(){const t="win32"===this.platform?"netstat -nao":"fast"===this.speed?`lsof -i :${this.ports}`:"lsof -i -P -n";try{const{stdout:s}=await e(t),r=s.split("\n");return"win32"===this.platform?this.parseWindowsPorts(r):this.parseUnixPorts(r)}catch(t){throw new Error(`Failed to list active ports: ${t.message}`)}}parseWindowsPorts(t){const s=new RegExp(`^ *${this.method.toUpperCase()} *[^ ]*:(\\d+),`,"gm");return t.reduce(((t,r)=>{const e=r.match(s);return e&&e[1]&&!t.includes(e[1])&&t.push(e[1]),t}),[])}parseUnixPorts(t){const s=/(?<=:\d{1,5})->|\b\d{1,5}(?=->|\s+\(CLOSED\)|\s+\(ESTABLISHED\)|\s+\(LISTEN\))/g;return t.flatMap((t=>t.match(s))).filter(Boolean)}promptUserToSelectPorts(t){return new Promise((s=>{const r=o.createInterface({input:process.stdin,output:process.stdout});t.forEach(((t,s)=>{this.success(`${s+1}. ${t}`)})),r.question("Select ports to operate on (comma-separated indices): ",(e=>{const o=e.split(",").map(Number).map((s=>t[s-1])).filter(Boolean);r.close(),s(o)}))}))}async handlePorts(t){switch(this.action){case"check":case"isExist":return this.showPortInfo(t);case"kill":return this.killPorts(t);default:throw new Error(`Unknown action: ${this.action}`)}}async isExistFast(t){const{stdout:s}=await e(`lsof -i :${t}`);return s.includes("LISTEN")}async isExistNormal(t){return(await this.listActivePorts()).includes(String(t))}success(t){console.log("[32m%s[0m",`${t}`)}error(t){console.log("[31m%s[0m",`${t}`)}async showPortInfo(t){for(const s of t)try{const t=await this.checkPortStatus(s);this.success(t?`Port ${s} is active.`:`Port ${s} is not active.`)}catch(t){this.error(`Error checking port ${s}: ${t.message}`)}}async checkPortStatus(t){const s="fast"===this.speed?this.isExistFast:this.isExistNormal;return await s.call(this,t)}async killPorts(t){for(const s of t)try{const t="win32"===this.platform?await this.getWindowsKillCommand(s):await this.getUnixKillCommand(s,this.method,this.graceful);this.log(`Executing: ${t}`);const r=await e(t);this.success(`Successfully killed port ${s} ${r.stdout}`)}catch(t){this.error(`Failed to kill port ${s}: ${t.message}`)}}async getWindowsKillCommand(t){try{const{stdout:s}=await e("netstat -nao"),r=s.split("\n"),o=new RegExp(`^ *${this.method.toUpperCase()} *[^ ]*:${t},`,"gm"),i=r.filter((t=>o.test(t)));return`TaskKill /F /PID ${i.reduce(((t,s)=>{const r=s.match(/(\d+)\w*/);return r&&t.push(r[1]),t}),[]).join(" /PID ")}`}catch(t){throw new Error(`Failed to get Windows kill command: ${t.message}`)}}async getUnixKillCommand(t,s="tcp",r=!1){const e=this.buildBaseCommand(s,t),o=r?"kill":"kill -9";try{if(!await this.checkIfProcessExists(t))throw new Error("No process running on port");return`${e} ${o}`}catch(t){throw new Error(`${t.message}`)}}buildBaseCommand(t,s){return`lsof -i ${t}:${s} | grep ${t.toUpperCase()} | awk '{print $2}' | xargs`}async checkIfProcessExists(t){const s="fast"===this.speed?this.isExistFast:this.isExistNormal;return await s.call(this,t)}}t.exports=async function(t,s={}){return new i(t,s).execute()}},96:(t,s,r)=>{const e=r(317);t.exports=function(t="",s={}){let r;Array.isArray(t)&&(t=t.join(";")),s=Object.assign({stdio:"pipe",cwd:process.cwd()},s);const o="win32"===process.platform?{cmd:"cmd",arg:"/C"}:{cmd:"sh",arg:"-c"};try{r=e.spawn(o.cmd,[o.arg,t],s)}catch(t){return Promise.reject(t)}return new Promise((s=>{let e="",o="";r.stdout&&r.stdout.on("data",(t=>{e+=t})),r.stderr&&r.stderr.on("data",(t=>{o+=t})),r.on("error",(r=>{s({error:r,stdout:e,stderr:o,cmd:t})})),r.on("close",(r=>{s({stdout:e,stderr:o,cmd:t,code:r})}))}))}},317:t=>{t.exports=require("child_process")},785:t=>{t.exports=require("readline")}},s={};function r(e){var o=s[e];if(void 0!==o)return o.exports;var i=s[e]={exports:{}},n=!0;try{t[e](i,i.exports,r),n=!1}finally{n&&delete s[e]}return i.exports}void 0!==r&&(r.ab=__dirname+"/");var e=r(136);module.exports=e})();